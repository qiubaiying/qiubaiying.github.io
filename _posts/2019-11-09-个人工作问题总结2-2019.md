---
layout:     post                        # 使用的布局（不需要改）
title:      个人工作问题总结2             # 标题 
subtitle:   POI/ZIP/AOP                        # 副标题
date:       2019-11-09                  # 时间
author:     AhogeK                      # 作者
header-img: https://ahogek.github.io/img/post-bg-alibaba.jpg     # 这篇文章标题背景图片
catalog: true                           # 是否归档
tags:                                   # 标签
    - 工作
    - 问题总结
    - Spring Boot
    - Excel
    - ZIP
---

### Spring Boot Poi Excel的导入导出
#### Excel导入
**导入需要注意导入的是2003还是2007**<br>
首先 2003 在 poi 中使用的是 *HSSFWorkbook* 而 2007 使用的是 *XSSFWorkbook*
下面是普通的导入代码：

```java
// @描述：是否是2003的excel，返回true是2003   
public static boolean isExcel2003(String filePath)  {    
    return filePath.matches("^.+\\.(?i)(xls)$");    
}    

//@描述：是否是2007的excel，返回true是2007   
public static boolean isExcel2007(String filePath)  {    
    return filePath.matches("^.+\\.(?i)(xlsx)$");    
}    

/**
* check Excel
* @param filePath
* @return
*/
public static boolean validateExcel(String filePath){  
    if (filePath == null || !(isExcel2003(filePath) || isExcel2007(filePath))){    
        return false;    
    }    
    return true;  
}  


void importExcel() throws IOException {
    File file = new File("C:\\Users\\11027\\Desktop\\工作簿1.xlsx");
    if(!file.exists()) {  
        System.out.println("文件为空");
    } else {
        InputStream is = new FileInputStream(file);
        // 获取文件名
        String fileName = file.getName();
        System.out.println(fileName);
        //根据版本选择创建Workbook的方式  
        Workbook wb = null;
        Sheet sheetAt = null;
            
        // 根据文件名判断文件是2003版本还是2007版本  
        if(ExcelImportUtils.isExcel2007(fileName)){  
            wb = new XSSFWorkbook(is);
            sheetAt = wb.getSheetAt(0);
        }else{  
            wb = new HSSFWorkbook(is);  
            sheetAt = wb.getSheetAt(0);
        }
        
        List<User> userlist = new ArrayList<User>();
        
        for (Row row : sheetAt) {
            int rowNum = row.getRowNum();
            if (rowNum == 0) {
                continue;
            }
            
            String name = row.getCell(0).getStringCellValue();
            Integer age = (int) row.getCell(1).getNumericCellValue();
            String email = row.getCell(2).getStringCellValue();
            User user = new User();
            user.setName(name);
            user.setAge(age);
            user.setEmail(email);
            
            int result = userMapper.insert(user);
            System.out.println("************************"+result);
        }
    }
}
```

工作中普遍公司的工具类中都会有 EXCEL 导入导出的专用工具类可以帮助我们省下很多代码

像导出代码，会先去查数据库拿到我们需要的数据，在利用 EXCEL 工具类将导出的数据逐一赋值新建Sheet表中的各个栏，这里会需要常量数据，即模板的表头和对应属性

### 文件的压缩导出
假如有这样的一个需求，上面的Excel进行批量导出，需要将批量导出的Excel进行压缩导出，这时我们就需要 *ZipStream* 这个类。但同样就要注意一些问题。<br>
往往我们在网上看到的代码如下：

```java
XSSFWorkbook workbook = new XSSFWorkbook();
//add some data
Zipoutputstream zipstream=new Zipoutputstream(//destination outputstream);
workbook.write(zipstream);
```
上一个导出中可以知道XSSFWorkbook是用于 2007 版的 EXCLE，因此，如果像这样直接写入到传参输出流的 zipstream 虽然可以压缩成功，但打开文件会注意到里面的 EXCEL文件就是个空文件，数据内容写在了zip里没写在 excel 文件里。

但仔细看其实这样的写法是适用于 **HSSFWorkbook** 但如果是 **XSSFWorkbook** 就需要 **ByteArrayOutputStream** 需要先将 workbook 写道 byteArray 输出流，再将 byteArray 输出流传到 zip流就可以拿到正常压缩 .xlsx 文件集。

```java
ZipOutputStream zos = new ZipOutputStream(//destination outputstream);
zos.putNextEntry(new ZipEntry("AnExcelFile.xlsx"));
ByteArrayOutputStream bos = new ByteArrayOutputStream();
workbook.write(bos);
bos.writeTo(zos);
zos.closeEntry();
// Add other entries as needed
zos.close();
```

### 关于 Spring Boot AOP 相关的一些问题
> 先提下，环绕通知 ProceedingJoinPoint 执行proceed方法的作用是让目标方法执行，这也是环绕通知和前置、后置通知方法的一个最大区别。Proceedingjoinpoint 继承了 JoinPoint 。是在JoinPoint的基础上暴露出 proceed 这个方法。proceed很重要，这个是aop代理链执行的方法。

使用AOP需要在application.yml中加入

```yml
spring:
  aop:
    proxy-target-class: true
```

1. @Pointcut 切入点
> 定义一个切点例如我们要在一个方法加上切入点，根据方法的返回的对象，方法名，修饰词来写成一个表达式或者是具体的名字

```java
package com.example.aop;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * 类定义为切面类
 */
@Aspect
@Component
public class AopTestController {
    private static final Logger logger = LoggerFactory.getLogger(AopTestController.class);
    /**
     * 定义一个切点
     */
    @Pointcut(value = "execution(public String test (..))")
    public void cutOffPoint() {
    }
}
```

切入点方法：

``` java
    @GetMapping("hello")
    public String test(){
        logger.info("hello world");
        return "i love java";
    }
```

如果想写个切入点在所有返回一个实体对象的方法
@Pointcut("execution(public com.example.entity.User (..))")
等很多写法，也可以直接作用在某些包下
*注意：private修饰的无法拦截*

现在主要将一个环绕通知
**环绕通知=前置+目标方法执行+后置通知，proceed方法就是用于启动目标方法执行的**

```java
@Around("exportCutOfPoint()")
public Object exportLog(ProceedingJoinPoint proceedingJoinPoint){
    // 目标方法执行前创建导出中心记录表并向数据库导入日志
    Object[] itemCodes = (Object[]) proceedingJoinPoint.getArgs()[0];
    ZwbkExportLog zwbkExportLog = new ZwbkExportLog();
    String exportLogId = UUID.randomUUID().toString().replace(AffairCommonConstants.MINUS, "");
    zwbkExportLog.setId(exportLogId);
    zwbkExportLog.setDerivedName(UserUtil.getUser().getUserName());
    zwbkExportLog.setDerivedType((String)proceedingJoinPoint.getArgs()[1]);
    zwbkExportLogMapper.insert(zwbkExportLog);
    Object obj;
    try{
        // 执行目标方法
        obj = proceedingJoinPoint.proceed();
        // 查询所有导出事项的事项信息
        QueryWrapper<ZwbkItemDirectory> queryWrapper = new QueryWrapper<>();
        queryWrapper.in("item_code", itemCodes);
        List<ZwbkItemDirectory> zwbkItemDirectoryList =  zwbkItemDirectoryMapper.selectList(queryWrapper);
        // 创建详细表中心并记录日志
        ZwbkExportLogDetails zwbkExportLogDetails = new ZwbkExportLogDetails();
        zwbkItemDirectoryList.forEach(zwbkItemDirectory -> {
            zwbkExportLogDetails.setExportCenterLogId(exportLogId);
            zwbkExportLogDetails.setItemCodeProd(zwbkItemDirectory.getItemCodeProd());
            zwbkExportLogDetails.setItemName(zwbkItemDirectory.getItemName());
            zwbkExportLogDetails.setAreaId(zwbkItemDirectory.getAreaId());
            zwbkExportLogDetails.setAreaCode(zwbkItemDirectory.getAreaCode());
            zwbkExportLogDetails.setAreaName(zwbkItemDirectory.getAreaName());
            zwbkExportLogDetails.setItemDeptId(zwbkItemDirectory.getItemDeptId());
            zwbkExportLogDetails.setItemDeptCode(zwbkItemDirectory.getItemDeptCode());
            zwbkExportLogDetails.setItemDeptName(zwbkItemDirectory.getItemDeptName());
            zwbkExportLogDetails.setItemNature(zwbkItemDirectory.getItemNature());
            zwbkExportLogDetailsMapper.insert(zwbkExportLogDetails);
        });
    } catch (Throwable throwable) {
        obj=throwable.toString();
    }
    return obj;
}
```

>1.环绕通知可以项目做全局异常处理
>2.日志记录
>3.用来做数据全局缓存
>4.全局的事物处理 等