---
layout:     post                    # 使用的布局（不需要改）
title:      Java核心技术学习笔记2           # 标题 
subtitle:   继承-类、超类和子类             #副标题
date:       2019-10-18              # 时间
author:     AhogeK                      # 作者
header-img: https://ahogek.github.io/img/core_java.jpg   #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - java
    - 学习笔记
---
### 类、超类和子类
#### 定义子类

```java
public class Manager extends Employee {
  添加方法和域
}
```

已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class)或孩子类（child class）。
**将通用的方法放在超类，而将具有特殊用途的方法放在子类中**

#### 覆盖方法

>超类中提供的公共的方法，虽用途相同，但可能实现会有所差异，这时就可以提供一个覆盖（override）方法。

*注：有些人认为 super 与 this 引用是类似的概念，实际上，这样比较并不恰当。这是因为 super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字*

#### 子类构造器

``super()``调用父类的构造（子类构造器的第一条语句）
*注：关键字 this 有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，这两个关键字的使用方式很相似。调用构造器的语句只能作另一个构造器的第一条语句出现。构造参数即可以传递给本类（this）的其他构造器，也可以传递给超类（super）的构造器*

(不同对象薪水上的区别)

```java
package inheritance;

/**
 * This program demonstrates inheritance.
 * @version 1.21 2004-02-21
 * @author Cay Horstmann
 */
public class ManagerTest
{
   public static void main(String[] args)
   {
      // construct a Manager object
      Manager boss = new Manager("Carl Cracker", 80000, 1987, 12, 15);
      boss.setBonus(5000);

      Employee[] staff = new Employee[3];

      // fill the staff array with Manager and Employee objects

      staff[0] = boss;
      staff[1] = new Employee("Harry Hacker", 50000, 1989, 10, 1);
      staff[2] = new Employee("Tommy Tester", 40000, 1990, 3, 15);

      // print out information about all Employee objects
      for (Employee e : staff)
         System.out.println("name=" + e.getName() + ",salary=" + e.getSalary());
   }
}
```

```java
package inheritance;

import java.time.*;

public class Employee
{
   private String name;
   private double salary;
   private LocalDate hireDay;

   public Employee(String name, double salary, int year, int month, int day)
   {
      this.name = name;
      this.salary = salary;
      hireDay = LocalDate.of(year, month, day);
   }

   public String getName()
   {
      return name;
   }

   public double getSalary()
   {
      return salary;
   }

   public LocalDate getHireDay()
   {
      return hireDay;
   }

   public void raiseSalary(double byPercent)
   {
      double raise = salary * byPercent / 100;
      salary += raise;
   }
}
```

```java
package inheritance;

public class Manager extends Employee
{
   private double bonus;

   /**
    * @param name the employee's name
    * @param salary the salary
    * @param year the hire year
    * @param month the hire month
    * @param day the hire day
    */
   public Manager(String name, double salary, int year, int month, int day)
   {
      super(name, salary, year, month, day);
      bonus = 0;
   }

   public double getSalary()
   {
      double baseSalary = super.getSalary();
      return baseSalary + bonus;
   }

   public void setBonus(double b)
   {
      bonus = b;
   }
}
```

#### 继承层次
由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy）。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链（inheritance chain）。

#### 多态
> 讲多态前先再来说说继承，继承关系有个简单规则 -> "is-a" 例如：每个经理都是雇员。这是一种置换法则，程序中出现超类对象的任何地方都可以用子类对象置换。
在 Java 程序设计语言中，对象变量是多态的。例如一个雇员数组中的一个元素可以与boss引用同一个对象，但该元素编辑器将依旧看成雇员对象。 -> 不能将一个超类的引用赋给子类变量。
**使用 ``new managers[10]`` 创建的数组是一个经理数组，如果试图存储一个*Employee*类型的引用就会引发*ArrayStoreException*异常**

#### 理解方法调用
调用过程：
1. 编译器查看对象的声明类型和方法名
2. 编译器将查看调用方法时提供的参数类型 *方法名和参数列表称为方法的签名*
3. 如果时 private 方法、static 方法、final 方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方法称为静态绑定（static binding）
4. 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与 x 所引用对象的实际类型最合适的那个类的方法。
**在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。如果超类方法是 public，子类方法一定要声明为 public**

#### 阻止继承：final类和方法
阻止人们利用某个类定义子类，不允许扩展的类被称为 *final* 类。

```java
public final class Executive extends Manager {
   ...
}
```

类中的特定方法也可以被称为 final。子类不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法）
*域也可以被声明为 final。对于 final 域来说，构造对象之后就不允许改变它们的值了。**将一个类声明为 final 只有其中的方法自动成为 final 而不包括域***
<br>
目的：确保他们不会在子类中改变语义。<br>
在早期版本的 Java 中，有些程序员为了避免动态绑定带来的系统开销而使用 final 关键字。如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程被称为内联（inlining）

#### 强制类型转换

将一个类型强制转换成另外一个类型的过程被称为类型转换。

对象引用的转换语法与数值表达式的类型转换类似，仅需要一对用一对圆括号将目标类名括起来，并放置需要转换的对象引用之前就可以了。

``Manager boss = (Manager) staff[0]``

进行类型转换的*唯一原因*：在暂时忽视对象的实际类型之后，使用对象的全部功能。

在 Java 中，每个对象变量都属于一个类型。类型描述了这个变量所引用的以及能够引用的对象类型。

*将一个超类的引用赋给一个子类变量，必须进行类型转换*

试图在继承链上进行向下的类型转换，并且“谎报”有关 对象包含的内容，会产生一个 **ClassCastException**

在进行类型转换之前，先查看一下是否能够成功地转换。这个过程简单地使用 **instanceof** 操作符就可以实现。

```java
if (staff[1] instanceof Manager) {
   boss = (Manager) staff[1];
   ...
}
```

如果这个类型转换不成功，编译器就不会进行这个转换。

* 只能在继承层次内进行类型转换。
* 在将超类转换成子类之前，应该使用 instanceof 进行检查。

如果 x 为 null，进行下列测试

``x instanceof C``

不会产生异常，只会返回 false。之所以这样处理是因为 null 没有引用任何对象，当然也不会引用 C 类型的对象

**在一般情况下，因该尽量少用类型转换和 instanceof 运算符**

#### 抽象类

>许多程序员认为, 在抽象类中不能包含具体方法 。 建议尽量将通用的域和方法 (不管是否是抽象的)放在超类(不管是否是抽象类) 中。

抽象方法充当着占位的角色 , 它们的具体实现在子类中 。 扩展抽象类可以有两种选择 。
一种是在抽象类中定义部分抽象类方法或不定义抽象类方法 , 这样就必须将子类也标记为抽
象类 ; 另一种是定义全部的抽象方法 , 这样一来 , 子类就不是抽象的了 。

类即使不含抽象方法, 也可以将类声明为抽象类 。
抽象类不能被实例化 。 也就是说, 如果将一个类声明为 abstract , 就不能创建这个类的对
象 。

*需要注意, 可以定义一个抽象类的对象变量, 但是它只能引用非抽象子类的对象 。*

``Person p = new Student ("Vinee Vu", "Economics");``

这里的 p 是一个抽象类 Person 的变量, Person 引用了一个非抽象子类 Student 的实例 。

```java
/**
 * This program demonstrates abstract classes.
 */
public class PersonTest {
   public static void main(String[] args) {
      Person[] people = new Person[2];

      // fill the people array with Student and Employee objects
      people[0] = new Employee("Harry Hacker", 50000, 1989, 10 ,1);
      people[1] = new Student("Marria Morris", "computer science");

      // print out names and descriptions of all Person objects
      for (Person p : people) {
         System.out.println(p.getName() + ", " + p.getDescription());
      }
   }
}
```

```java
public abstract class Person {
   public abstract String getDescription();
   private String name;

   public Person(String name) {
      this.name = name;
   }

   public String getName() {
      return name;
   }
}
```

```java
public class Employee extends Person {
   private double salary;
   private LocalDate hireDay;

   public Employee (String name, double salary, int year, int month, int day) {
      super(name);
      this.salary = salary;
      hireDay = LocalDate.of(year, month, day);
   }

   public double getSalary() {
      return salary;
   }

   public LocalDate getHireDay() {
      return hireDay;
   }

   public String getDescription() {
      return String.format("an employee with a salary of $%.2f", salary);
   }

   public void raiseSalary(double byPercent) {
      double raise = salary * byPercent / 100;
      salary += raise;
   }
}
```

```java
public class Student extends Person {
   private String major;

   /**
    * @param name the student's name
    * @param major the student's major
    */
   public Student(String name, String major) {
      // pass n to superclass constructor
      super(name);
      this.major = major;
   }

   public String getDescription() {
      return "a student majoring in " + major;
   }
}
```

是否可以省略 Person 超类中的抽象方法 , 而仅在 Employee 和 Student 子类中定义 getDescription 方法呢 ? 如果这样的话, 就不能通过变量 p 调用 getDescription 方法了 。 编译器只允许调用在类中声明的方法 。
在 Java 程序设计语言中, 抽象方法是一个重要的概念 。 在接口 ( interface ) 中将会看到更多的抽象方法 。

#### 受保护访问

>在有些时候，人们希望超类中的某些方法允许被子类访问， 或允许子类的方法访问超类的某个域。为此， 需要将这些方法或域声明为protected。

**在实际应用中，要谨慎使用protected 属性。**

受保护的方法更具有实际意义。如果需要限制某个方法的使用， 就可以将它声明为 protected。这表明子类（可能很熟悉祖先类）得到信任， 可以正确地使用这个方法， 而其他类则不行。

1. 仅对本类可见 ———— private。
2. 对所有类可见 ———— public。
3. 对本包和所有子类可见 ———— protected。
4. 对本包可见 ———— 默认，不需要修饰符。