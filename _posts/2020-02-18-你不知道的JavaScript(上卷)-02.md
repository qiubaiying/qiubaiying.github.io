---
layout:     post
title:      你不知道的JavaScript(上卷)-笔记02
subtitle:   词法作用域
date:       2020-02-18
author:     CHM
header-img: img/home-bg.jpg
catalog: true
tags:
    - JS
    - 你不知道的JavaScript
---


## 前言
你不知道的JavaScript[上卷]主要分为两部分。第一部分是:作用域与闭包；第二部分是:this与对象原型。这里主要讲的是第一部分的第二章。**词法作用域**。

作用域共有两种主要的工作模式。词法作用域 & 动态作用域（eg:Bash脚本）。

## 词法阶段
简单来说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

**无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数声明时所处的位置决定。**

## 欺骗词法
如果词法作用域完全由写代码期间函数所声明的位置来定义的，那么怎样才能在运行时来“修改”（欺骗）词法作用域呢？

js中有两种机制来实现这个目的： eval(..) & with。（**欺骗词法作用域会导致性能下降,不要使用**）

#### 性能
JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。

但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。

最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。

如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代
码会运行得更慢这个事实。

## 小结
词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在
运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作
用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认
为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

### 参考 
- [你不知道的JavaScript[上卷]](https://kingyinliang.github.io/PDF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf)
