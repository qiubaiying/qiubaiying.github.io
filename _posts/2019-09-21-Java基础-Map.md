---
layout:     post 
title:      Java基础0921
subtitle:   Map
date:       2019-09-21
author:     张鹏
header-img: img/post-bg-debug.png
catalog: true   
tags:                         
    - Java
---

### Map

#### 概要：
- java.util中的集合类包含了Java中某些最常用的类。最常用的集合类是List和Map
- Map提供了一个更为通用的元素存储方法。Map集合类用于存储元素对（称作“键”和“值”）。其中每一个键映射到一个值

#### Map用法

- Java中自带了各种Map类，这些Map类可归为三种类型

1. 通用Map，用于在应用程序中管理映射，通常在java.util程序包中实现。包括：`HashMap、Hashtable、Properties、LinkedHashMap、IdentityHashMap、TreeMap、WeakHashMap、ConcurrentHashMap`
2. 专用Map，通常我们不必亲自创建此类Map，而是通过某些其他类对其进行访问。包括：`java.util.jar.Attributes`、`javax.print.attribute.standard.PrintStateReasons`、`java.security.Provider`、`java.awt.RenderingHints`、`javax.swing.UIDefaults`
3. 一个用于帮助我们实现自己的Map类的抽象类：`Abstract Map`

#### 类型区别

- HashMap
   - 最常用的Map，他根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为Null（多条的话会被覆盖）；允许多条记录的值为null。是非同步的。

- TreeMap
   - 能够把它保存的记录根据键（key）排序，默认是升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。是非同步的。

- Hashtable
   - 与HashMap类似，不同的是：key和value的值均不允许为null；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtable在写入时会比较慢。

- LinkedHashMap
   - 保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢。key和value均允许为空。是非同步的。

#### Map初始化

```java
Map<String,String> map=new HashMap<String,String>();
```

#### 插入元素

```java
map.put("key1","value1");
```

#### 获取元素

```java
map.get("key1");
```

#### 移除元素

```java
map.remove("key1");
```

#### 清空Map

```java
map.clear();
```

#### Map遍历

- 增强for循环遍历
   - 使用keySet()遍历

```java
for(String key:map.keySet()){
    System.out.println(key+":"+map.get(key));
}
```
   - 使用entrySet()遍历

```java
for(Map.Entry<String,String> entry:map.entrySet()){
    System.out.println(entry.getKey()+":"+entry.getValue());
}
```

- 迭代器遍历
   - 使用keySet()遍历

```java
Iterator<String> iterator=map.keySet().iterator();
while(iterator.hasNext()){
    String key=iterator.next();
    System.out.println(key+":"+map.get(key));
}
```

   - 使用entrySet()遍历

```java
Iterator<String,String> iterator=map.entrySet().iterator();
while(iterator.hasNext()){
    Map.Entry<String,String> entry=iterator.next();
    System.out.println(entry.getKey()+":"+entry.getValue());
}
```

#### 循环总结

1. 增强for循环使用方便，但性能较差，不适合处理超大量级的数据
2. 迭代器的遍历速度要比增强for循环快很多，是增强for循环的两倍左右
3. 使用entrySet遍历的速度要比keySet快很多，是keySet的1.5倍左右

#### Map排序（HashMap、Hashtable、LinkedHashMap排序）

```java
Map<String,String> map=new HashMap<String,String>();
map.put("a","c");
map.put("b","b");
map.put("c","a");

//通过ArrayList构造函数把map.entrySet()转换成list
List<Map.Entry<String,String>> list=new ArrayList<Map.Entry<String,String>>(map.entrySet());
//通过比较器实现比较排序
Collections.sort(list,new Comparator<Map,Entry<String,String>>(){
    public int compare(Map.Entry<String,String> mapping1,Map.Entry<String,String> mapping2){
        return mapping1.getKey().compareTo(mapping2.getKey());
    }
});

for(Map.Entry<String,String> mapping:list){
    System.out.println(mapping.getKey()+":"+mapping.getValue());
}
```