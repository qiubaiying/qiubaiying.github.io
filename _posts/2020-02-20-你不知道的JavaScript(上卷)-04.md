---
layout:     post
title:      你不知道的JavaScript(上卷)-笔记04
subtitle:   提升
date:       2020-02-20
author:     CHM
header-img: img/post-bg-car.jpg
catalog: true
tags:
    - JS
    - 你不知道的JavaScript
---


## 前言
你不知道的JavaScript[上卷]主要分为两部分。第一部分是:作用域与闭包；第二部分是:this与对象原型。这里主要讲的是第一部分的第四章。**提升**。

## 先有鸡还是先有蛋
直觉上会认为JavaScript代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误但。

考虑以下代码：
```
a = 2;
var a;
console.log(a)
```
```
console.log(a);
var a = 2
```
第一段代码结果是2，第二段代码结果是undefeated。

> 到底是声明（蛋）在前，还是赋值（鸡）在前?

## 编译器再度来袭
回顾第一章中关于编译器但内容。 引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段中第一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。第二章中展示了这个机制，也正是词法作用域的核心内容。

因此，正确的思考思路是，包括变量和函数声明在内的所有的声明都会在执行前首先被处理。

当你看到 var a = 2; 时，可能会认为这是一个声明。但JavaScript实际上会将其看成两个声明:var a; a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。这个过程就叫作提升。

换句话说，先有蛋(声明)后有鸡(赋值)。
> 每个作用域都会进行提升操作。

函数声明会被提升，但是函数表达式却不会被提升。
```
foo() // 不是ReferenceError ， 而是TypeError！
var foo = function bar() {
    // ...
}
```
这段程序中的变量标识符 foo() 被提升并分配给所在作用域(在这里是全局作用域)，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不 是函数表达式，那么就会赋值)。foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。

## 函数优先
函数声明和变量声明都会被提升。但是一个值得注意的一节（这个细节可以出现有多个"重复"声明的代码中）是函数会首先被提升，然后才是变量。

考虑以下代码:
```
foo();
var foo;
function foo(){
    console.log(1);
}
foo = function(){
    console.log(2)
}
```
会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:

function foo(){
    console.log(1)
}

foo() 

foo = function(){
    console.log(2)
}

注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。

尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。
```
foo(); // 3
function foo() { 
    console.log( 1 );
}
var foo = function() { 
    console.log( 2 );
};
function foo() { 
    console.log( 3 );
}
```

虽然这些听起来都是些无用的学院理论，但是它说明了在同一个作用域中进行重复定义是 非常糟糕的，而且经常会导致各种奇怪的问题。
一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代 码暗示的那样可以被条件判断所控制:
```
foo(); // "b"
var a = true; 
if (a) {
    function foo() { console.log("a"); } 
} else {
    function foo() { console.log("b"); }
}
```
但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。

## 小结
我们习惯将 var a = 2;当作是一个声明，而实际上JavaScript引擎并不这么认为。它将var a; 和a = 2;当作是两个独立的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。

这意味着无论声明在作用域中的什么位置，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。

声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。

要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引
起很多危险的问题!

### 参考 
- [你不知道的JavaScript[上卷]](https://kingyinliang.github.io/PDF/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89.pdf)