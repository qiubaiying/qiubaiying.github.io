---
layout:     post
title:      快速幂详解
subtitle:   算法
date:       2018-11-20
author:     XHT
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - ACM
---

## 关于普通快速幂
>我们先从十进制开始讲起

曾经处理过一个m^n的大数问题。在问题里m是可以用int类型表示的数，而n是一个长字符串。
我们可以怎么处理呢
在n可以用int表示的情况下。我们举一个栗子

21^19234次

我们可以把这个问题拆分成很多个小问题

21^(10000+9000+200+30+4)或者更直接 21^10000\*21^9000\*21^200\*21^30\*21^4

我们可以从最低位开始迭代到高位



从最低位开始处理用a[10]数组存下
``` c++
a0=21^0  a1=21^1  a2=21^2  a3=21^3  a4=21^4
a5=21^5  a6=21^6  a7=21^7  a8=21^8  a9=21^9
```
可以得到21^(10000+9000+200+30+4)里的21^4

对a[10]里的所有元素值更新为原本的十次方   我们可以处理出
``` c++
a0=21^0  a1=21^10  a2=21^20  a3=21^30  a4=21^40
a5=21^50  a6=21^60  a7=21^70  a8=21^80  a9=21^90
```
得到21^(10000+9000+200+30+4)里的21^30

继续

得到得到21^(10000+9000+200+30+4)里的21^200

按着迭代过程,我们可以直接设计一个for循环来实现这一过程

相乘之后得到最后的结果

整个处理时间复杂度是n的字符串长度*（10-1=9）


>当把十进制进行压缩会发生什么呢？

考虑一个更简单的数字
n的88次方  (注意这里的88为十进制下的表示)
我们所需要的时间复杂度为字符串长度*（10-1=9）


这里的时间主要花在当低位向高位转变是所化废的时间,以及所需要处理的问题长度


那变成九进制的时候呢?

同样是n的88次方  (注意这里的88为九进制下的表示)
我们所需要的时间复杂度为字符串长度*（9-1=8）

字符串长度好像是Log(9)88?

那继续往下

Log(8)88 * 7

Log(2)88 * 1

???

Log(2)88 比log(10)88处理出来的字符串长度差别是多少呢？

好像差的不是特别大欸,可惜知识全部还给老师了




>当十进制变成二进制的算法


当次方变成用二进制表示的时候呢？讨论21^（1010101010101）

又从最低位开始

a1=1 -> a1=2 -> a1=4 -> a1=8 -> a1=16 -> a1=32 -> a1=64

如果当前位上的值为1 加上当前位所对应的值  (好像很绕ORZ)

如果用代码表示的话,那就是

``` c++
ll quick_pow(int a,int b,int mod)
{
    ll sum=1;
    ll c=a;
    while(b)
    {
        if(b%2==1)
        {
          sum*=a;
          sum%=mod;
        }
        a=a*a;
        a=a%mod;
        b=b/2;
    }
    return sum;
}

```
这就是从最低位开始迭代到最高位的二进制各位置的值(相当于十进制里的十位，百位，千位，万位)

时间复杂度就变成了Log(2)次方值



## 关于矩阵快速幂
>从斐波那契数列开始讲起

F(n)=F(n-1)+F(n-2)

如何用一个矩阵表示呢
``` c++
|  1  1  |     |  F(n-1)  0  |     | F(n)    0 |

|        |  ×  |             |   = |           |

|  0  1  |     |  F(n-2)  0  |     | F(n-1)  0 |
```

如果我们要求F(n+1)时,就变成了

``` c++
|  1  1  |     |  1  1  |  |  F(n-1)  0  |     | F(n)    0 |

|        |  ×  |        | ×|             |   = |           |

|  0  1  |     |  0  1  |  |  F(n-2)  0  |     | F(n-1)  0 |
```


如果把F(n-1) 这些换成F(2),F(1)时呢?

希望大家自己动一下手去看看  (ง •_•)ง


>如何进行矩阵加速呢?

我们发现F(1) -> F(n)

中间不过是一堆相同的矩阵进行相乘计算,当我们回到开头的快速幂时

其实就可以把这整个矩阵看作开头里的一个n，这个矩阵连乘的次数看成m

又变回了开头的n^m快速幂求解

只不过这次×需要自己重新定义一下
